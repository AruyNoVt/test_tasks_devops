- **Task 1** - задача состоит в том, чтобы создать нового пользователя на сервере/серверах и добавить его публичный SSH-ключ в файл `~/.ssh/authorized_keys`, чтобы этот пользователь мог подключаться к серверу/серверам без ввода пароля.

Этапы решения:
1. Подготовил YAML-файл с публичными ключами, называется `ssh_pub_keys.yml`, куда поместил заранее сгенерированный публичный ключ, через команду:

   ```bash
   ssh-keygen -t rsa -b 4096 -C "mail@example.ru"
   ```
2. Настроил Ansible для работы с удалёнными серверами, создал файл `hosts` и добавил IP-адреса управления серверами.

3. Создал playbook, в котором предварительно необходимо указывать логин нового юзера, который из YAML-файла с публичными ключами вытащит публичный ключ и зальёт его на соответствующие серверы. Запустить можно командой:
   ```bash
   ansible-playbook -i hosts create_user_and_add_ssh_key.yml -u user1
   ```
   где `user1` — специальный юзер для входа.
   
- **Task 2** - Оценка навыков и знаний в области CI/CD, умение создавать CI/CD pipeline, проверка на внимательность к деталям, ибо танцы с бубнами при установке Gitlab и регистрации Runner действительно усиливают внимательность и усидчивость, а может, это всё кривые руки виноваты. 

Этапы решения:
1. Нашел на просторах файла `index.js`, по гайдам написал Dockerfile, далее выполнив команду ```bash npm init``` - создал package.json. 
2. Настройка CI/CD, в `.gitlab-ci.yml` указал три стадии: build, test, deploy, в каждой выполнил команды. 
Итог: немного научился работаь с Gitlab CI/CD, попробовал закоммитить файлы, запустил pipeline, автоматизировал - уже при каждом новом push все будет лететь в основную ветку.

- **Task 4** - общие понимание структуры и слоев в Dockerfile, оптимизация и знакомство с бестс практиками.
  Прочитал и нашел в терынете общие рекомендации:
  1. Упорядоченность команд: Выполняется много RUN команд, для уменьшения количества слоев образа и повышения скорости сборки можно объединить несколько команд в одну, используя `&&`.
- Очистка: Необходимо очищать временные файлы, чтобы уменьшить размер образа, например, после загрузки архива.
- Контроль за изменениями: Если в будущем изменится любой файл в коде, Docker будет использовать кэш для прежних слоев, до тех пор, пока не изменится последний `COPY`, что может привести к повторной установке зависимостей, необходимо внимательно планировать порядок операций. 
